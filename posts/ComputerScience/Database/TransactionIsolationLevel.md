---
created: 2021-07-11
modified: 2021-07-12
tags: [DB, DataBase]
title: Transaction
author: Yo0oN
categories: [DataBase]
---

## 1. Transaction Isolation Level 트랜잭션 격리수준

트랜잭션 격리수준은 트랜잭션 내에서 변경된 데이터를 볼 수 있도록 허용할지 말지를 정하게 해준다.    
격리수준에는 4가지가 있다.    

### 1-1. Read Uncommitted

가장 낮은 수준의 격리수준으로, 일반적인 곳에서는 거의 사용하지 않는 수준이다.    
트랜잭션 내에서 데이터가 변경될 경우 커밋까지 완료되어야 트랜잭션이 끝나게 되는데, Read Uncomitted는 커밋되지 않았음에도 다른 트랜잭션이 읽는 것을 허용한다.    

그래서 트랜잭션 A가 데이터 변경 후 아직 커밋되지 않았음에도 트랜잭션 B는 A가 번경한 내용을 읽어오게된다.    
커밋되지 않은 데이터이기 때문에 디스크가 아닌 버퍼풀에 있는 내용을 읽어오고, 이런 현상을 *Dirty Read*라고 한다.    
만약 트랜잭션 A가 잘못되어서 롤백을 하게된다면 트랜잭션 B가 이전에 읽은 쿼리문을 똑같이 사용하더라도 내용이 변경된다.

Read Uncommitted의 경우 데이터의 일관성을 유지할 수 없다.    


### 1-2. Read Committed

오라클에서의 기본 격리 수준으로, 커밋이 완료된 데이터만 조회할 수 있는 수준이다.    
커밋이 완료된 데이터를 읽어오기 때문에 다른 트랜잭션은 변경되었지만 커밋되지 않은 데이터를 언두로그에서 읽어온다.

Read Committed의 문제는 A 트랜잭션에서 데이터를 수정한 후 B 트랜잭션에서 이제 그 내용을 읽으면 처음엔 아직 커밋되지 않은 상태이기 때문에 변경 전의 데이터가 보인다.    
하지만, A 트랜잭션이 완료되고 변경 내용이 커밋된다면 B 트랜잭션에서 다시 그 내용을 읽었을 때 변경된 데이터를 읽어오게 된다.    
그래서 하나의 트랜잭션에서 일정 범위의 데이터를 두번 이상 읽었을 때 조회 결과가 다른 문제가 있으며, 이런 현상을 *Phantom Read*라고 한다.

추가로 Master/Slave가 적용된 DB에서는 사용할 수 없는 격리수준이다.


### 1-3. Repeatable Read

트랜잭션이 완료될 때까지 트랜잭션 내에서 SELECT 명령을 사용하면 항상 같은 결과가 나오도록 해주는 수준으로, 데이터의 내용이 항상 동일함을 보장해준다.    
이 수준에서는 각 트랜잭션에 고유한 번호를 부여하여, 다른 트랜잭션에서 같은 레코드를 수정하려 할 때, 자신의 트랜잭션보다 낮은 곳에서 변경된 것만 보이고, 큰 곳에서 변경된 것은 보이지 않도록 해서 보장해준다.    

1. 10번 트랜잭션이 A 테이블을 조회한다.
1. 12번 트랜잭션이 A 테이블을 변경하고 커밋한다.
2. 10번 트랜잭션이 A 테이블을 조회할 때 12번이 바꿨지만, 자신보다 번호가 높은 곳에서 바꾼것이기 때문에 12번이 바꾸기 전의 데이터를 조회한다.

위와 같은 방식으로 각 트랜잭션에 번호를 부여하여 이루어진다.    
그리고 바이너리 로그를 사용 중(=Master/Savle)일때는 최소 Repetable Read 수준 이상을 사용해야한다.


### 1-4. Serializable

가장 높은 수준으로, 한 트랜잭션에서 읽고 쓰는 레코드가 있다면 그 데이터에는 Shared Lock이 걸려 다른 트랜잭션에서 접근할 수 없도록 한다.    
그렇기 때문에 위에서 발생한 문제들은 일어나지 않지만, 대신 동시성이 중요한 곳에서는 사용하지 않는 수준이다.

