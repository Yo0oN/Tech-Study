|작성일|수정일|
|:----|:----|
|2020-12-23|2020-12-26|

--------

### 목표
- 자바의 상속에 대해 학습하세요.

### 학습할 것 (필수)
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스


## 1. 자바 상속의 특징

상속이란 기존의 클래스를 재사용해서 새로운 클래스를 만드는 것이다.

부모가 자식에게 재산을 물려주듯, 자바에서도 부모클래스가 자식클래스에게 상속을 해줄 수 있다.<br>
상속을 받으면 하위클래스는 상위클래스의 필드와 메서드를 사용할 수 있고, 추가로 코드를 작성할수도 있다.<br>
대신 생성자와 초기화 블럭은 상속받을 수 없고, 하나의 자식클래스는 하나의 부모클래스만 상속받을 수 있다. 반대로 하나의 부모클래스는 여러 자식클래스에게 상속해줄 수 있다.

![제목 없음](https://user-images.githubusercontent.com/53729311/103137784-7f414e80-470f-11eb-9a9b-014123a67373.jpg)

자식클래스가 상속을 받을 때는 `extends`라는 키워드를 이용하여 아래와 같이 상속을 받는다.
```java
class Parent{
  public void hi(){
    System.out.println("hi");
  }
}

class Child extends Parent{
  public void hello(){
    System.out.println("hello");
  }
}
```
위에서 Child 클래스는 내부에 `hi()` 메서드가 없지만, Parent 클래스를 상속받고 있기 때문에 해당 메서드를 사용할 수 있다.<br>

<br>

## 2. super 키워드

super는 자식클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용하는 참조 변수이다.

```java
class Parent{
  String name = "Parent";
  
  public void hi() {
    System.out.println("hi! He is " + name);
  }
}

class Child extends Parent{
  String name = "Child";
  
  @Override
  public void hi() {
    super.hi();
    System.out.println(super.name + "is my parent. And my is " + this.name);
  }
}
```
위의 Child에서 `hi()` 메서드를 실행하면 결과는 `hi! He is Parent. Parent is my parent. And my name is Child`라는 결과가 나온다. 마치 지역변수와 멤버변수를 구분하기 위해 this 키워드를 사용한 것 처럼, super는 부모와 자식클래스에서 멤버변수를 구분하고자 할 때 사용할 수 있고, 부모클래스의 메서드를 불러오는데도 사용할 수 있다.

비슷하게 `super()`라는 것도 있는데, 이것은 부모클래스의 생성자를 호출하는 것이다.<br>

<br>


## 3. 메서드 오버라이딩

오버라이딩은 조상 클래스에게서 상속받은 메서드의 내용을 변경하는 것이다.<br>
상속받은 메서드를 그대로 사용해도 좋지만, 원한다면 각 클래스에 맞게 내용을 변경할 수 있는데, 변경을 하려면 몇가지 조건이 있다.

1. 조상클래스와 자식클래스의 메서드 이름이 같아야한다.
2. 매개변수가 같아야 한다.
3. 반환 타입이 같아야 한다.
4. 접근제어자는 조상 클래스의 메서드보다 같거나, 좁은 범위로만 변경 가능하다.
5. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
6. 인스턴스 메서드를 static으로 변경하거나 static 메서드를 인스턴스 메서드로 변경할 수 없다.

만약 이름은 같지만 그 외의 조건들이 다르다면 그냥 이름이 같은 메서드를 새로 만든것이지 오버라이딩 한것이 아니다.<br>
오버라이딩을 정확하게 하고싶다면 `@Override` 어노테이션을 이용하여 해당 메서드가 오버라이딩 되었음을 알려주어도 된다.

```java
class Parent{
  public void hi(){
    System.out.println("hi");
  }
}

class Child extends Parent{

  @Override
  public void hi(){
    System.out.println("hi! My name is...");
  }
  
  public void hi(String name) {
    System.out.println("hi! My name is " + name);
  }
}
```
위에서 `@Override` 어노테이션이 붙은 `hi()`와 아래의 `hi()`는 다른 메서드이다.

> 비슷한 이름으로 '오버로딩'이란것도 있으나, 전혀 오버로딩은 다른 의미이다.<br>

<br>

## 4. 다이나믹 메서드 디스패치

Dispatch 디스패치는 어떤 메서드를 호출한것인가를 결정하고, 실행하는 과정이다.<br>
Static 정적과 Dynamic 동적 디스패치로 나뉘는데, 정적 디스패치의 경우 컴파일시에 컴파일러가 메서드가 어떤 메서드를 호출하고 있는것인지 정확하게 알지만, 동적 디스패치는 오버라이딩 되어있는 경우 컴파일러가 정확히 알지 못하고 런타임시에 어떤 메서드가 실행되는지 결정되는 것이다.

이는 객체지향의 특징 중 하나인 다형성과도 관련있다.<br>
다형성이란 여러 형태를 가진다는 것인데, 객체를 만들 때 보통은 `Child c = new Child();`와 같은 형식으로 만든다. 하지만 다형성의 경우 객체의 타입을 본인이 아닌 조상클래스로 정할 수 있다.<br>
그래서 `Parent c = new Child();`와 같은 형식으로도 사용할 수 있게 되는데, 이런경우 객체의 타입은 Parent지만 실제로 담긴것은 Child타입의 객체가 담겨있게된다.<br>
이렇게 조상클래스를 타입으로 설정할 경우 런타임 시에 조상클래스의 메서드를 사용할 것인지, 자식클래스의 오버라이딩된 메서드를 사용할 것인지 정하는 것을 다이나믹 메서드 디스패치라고 한다.

> 하지만 조상클래스를 객체의 타입으로 하게될 경우, 조상클래스에서 상속받은 것들과, 오버라이딩한 메서드들은 사용할 수 있지만, 자식클래스에서 새로생성된 멤버들은 사용할 수 없다는 단점도 존재한다.<br>

<br>

## 5. 추상 클래스

추상클래스는 추상메서드를 포함하고 있는 클래스로, 아직 미완성인 클래스이다.<br>
미완성이기 때문에 객체를 만들 수 없는 대신 자식클래스가 추상클래스를 상속받아 추상메서드를 완성한다면, 자식클래스의 객체는 만들 수 있다.

추상메서드는 선언부는 작성했지만, 몸통은 작성되지 않은 것인데, 이렇게 추상메서드, 추상클래스를 이용하게 된다면 비슷한 동작을 가진 여러 클래스들의 코드를 모아 추상화 할 수 있다는 장점이 있다.<br>
부모클래스인 추상클래스에서 공통기능을 구현하고, 다른 클래스끼리 서로 다른 내용은 추상메서드로 남겨둔다. 그리고 자식클래스들은 추상클래스를 상속받아 추상메서드 부분만 구현하는것이다.

하지만 이럴경우 상속은 하나의 클래스만 받을 수 있으니 다른 클래스는 상속받을 수 없다는 단점이 있다.(이를 위해 인터페이스라는 것도 있다.)<br>

<br>

## 6. fianl 키워드

final 키워드는 변수, 메서드, 클래스에 상관없이 붙일 수 있는 키워드이다.

변수 앞에 붙을 경우 해당 변수는 상수가 되어 값을 변경시킬 수 없는 상수가 된다.<br>
그리고 클래스 앞에 붙을 경우 해당 클래스를 상속받을 수 없기 때문에 더이상 확장할 수 없다.<br>
마지막으로 메서드에 사용될 경우 오버라이딩을 할 수 없기 때문에 해당 메서드를 변경할 수 없게 된다.<br>

<br>

## 7. Object 클래스

Object 클래스는 모든 클래스들의 최상위에 있는 조상클래스로, 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object 클래스를 상속받는다.<br>
모든 클래스들의 조상 클래스이므로 모든 클래스들은 Object 클래스에 정의된 것들을 사용할 수 있는데, 대표적인것이 `toString()`, `equals(Object o)` 같은 메서드이다.
