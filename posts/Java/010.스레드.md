|작성일|수정일|
|:----|:----|
|2021-01-22|2021-01-22|

--------


### 목표
- 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.

### 학습할 것 (필수)
- Thread 클래스와 Runnable 인터페이스
- 쓰레드의 상태
- 쓰레드의 우선순위
- Main 쓰레드
- 동기화
- 데드락

### Thread?

실행중인 프로그램을 *프로세스*라고 한다. 프로세스는 *자원(메모리)* 와 *스레드*로 이루어져 있는데, 프로세스가 실행하도록 자원을 이용해 작업을 하는 일꾼이라고 생각하면 된다.<br>
하나의 프로세스 안에는 여러 스레드가 존재하며, 두개 이상인 경우 *멀티 스레드 프로세스*라고 한다.

## 1. Thread 클래스와 Runnable 인터페이스

자바에서 스레드를 구현할 때 두가지 방법을 사용할 수 있는데, Thread 클래스를 상속받거나, Runnable 인터페이스를 구현하는 것이다.

해당 Thread 클래스나 Runnable 인터페이스의 run() 메서드를 오버라이딩하는 방식이다.

```java
public class ThreadImplRunnable implements Runnable{
  @Override
  public void run(){
    // 실행할것...
  }
}

public class ThreadExtThread extends Thread{
  @Override
  public void run() {
    // 실행할것...
  }
}
```
Runnable 인터페이스 내부에는 run()메서드 하나만 있고, Thread 클래스는 Runnable 인터페이스를 구현하여 run()메서드 뿐만 아니라 다른 메서드들도 가지고 있다.

둘의 차이점이 있는데, 인스턴스 생성 방식이 다르다.<br>

Runnable를 구현했을 때는, 구현 클래스를 인스턴스화 하고, Thread의 생성자에 매개변수로 넣어주어야 하고,
Thread 클래스를 상속받았을 경우, 상속받은 클래스를 인스턴스화 해서 바로 사용이 가능하다. 

```java
// Runnable 인터페이스를 구현 시
ThreadImplRunnable threadImplRunnable = new ThreadImpleRunnable();
Thread threadImpl = new Thread(threadImpleRunnable)

threadImpl.start()


// Thread 클래스를 상속 시
ThreadExtThread threadExtTread = new ThreadExtThread();

threadExtThread.start()
```

스레드를 시작할때는 start() 메서드를 호출하는데, start() 메서드가 실행될 경우 발생되는 일이 있다..

### Main스레드, stack 영역

자바 프로그램을 처음 실행하면 제일 처음으로 main 스레드가 실행된다. main 스레드는 우리가 따로 만들어주지 않더라도 알아서 생성된다.

만약 우리가 새로운 스레드를 만들어 사용하게 된다면, main 스레드가 start() 메서드를 실행한다.<br>

그러면 JVM 메모리 영역 중 stack 영역이 있는데 *stack 영역은 스레드별로 다르게 생성*되기 때문에 start() 메서드는 새로운 스레드를 위한 새로운 stack 영역을 만들고, 해당 stack에서는 run()메서드를 실행하여 run() 내부의 작업을 실행한다.<br>
이렇게 여러 스레드가 실행되면, stack 영역을 번갈아가며 작업을 수행하게 된다.<br>



## 2. 쓰레드의 상태

스레드에는 5가지 상태가 있다.

1. NEW : 스레드가 생성되고 아직 start()가 호출되지 않은 상태
2. RUNNABLE : 실행 중 또는 실행 가능 상태
3. BLOCKED : 동기화 블럭에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)
4. WAITING, TIME_WAITING : 실행가능하지 않은 일시정지 상태
5. TERMINATED : 스레드 작업이 종료된 상태<br>


## 3. 쓰레드의 우선순위

스레드에는 `priority` 멤버변수가 있다. 해당 변수는 우선순위를 나타내는데, 1부터 10 사이의 값으로 스레드의 우선순위를 정해준다.(기본값은 5)

우선순위를 설정할 때 헷갈릴 수 있는것이 있는데, 1이라고 하면 첫번째, 우선순위가 높은것 이라 생각할 수 있으나, 실제로는 10이 우선순위가 가장 높다.<br>
숫자가 클수록 우선순위가 높아지며, 우선순위가 높을수록 낮은 스레드들보다 더 자주 실행된다.<br>


## 4. 동기화

스레드를 그냥 사용하게 될 경우 문제가 생길 수 있다.

예를들어 은행 프로그램에 스레드1, 스레드 2가 있다고 해보자.<br>
스레드1과 2는 A의 계좌에서 돈을 빼고싶다. 계좌에는 5천원이 있는데 스레드 1과 스레드 2가 번갈아가면서 계좌를 확인하고, 돈을 빼는 작업을 할것이다.<br>
스레드 1에서 계좌의 잔고를 확인하니 5천원이다. 스레드 2에서도 잔고를 확인하니 5천원이 있다.<br>
스레드 1은 5천원에서 3천원을 출금하였다. 그런데 스레드 2도 잔고가 5천원이 있었으니 3천원을 출금하였다.<br>
둘다 3천원 출금에 성공하였고, 계좌를 보니 돈이 2천원이 남아있다. 5천원에서 6천원을 뺐는데 마이너스가 아닌 오히려 돈이 남은것이다.

여러 스레드를 사용하다보면 내가 생각한 결과가 제대로 나오지 않는 경우가 있다.<br>
이때 동기화를 이용하면 문제를 해결할 수 있다.

동기화를 하는 방법에는 몇가지가 있는데 그 중 대표적인 것이 `Synchronized` 키워드이다.<br>
Synchronized 키워드를 사용하면 멀티스레드 환경에서 여러 스레드가 해당 키워드를 사용한 곳에 동시에 접근하지 못하도록 내부적으로 lock을 걸어준다.<br>
스레드 1이 Synchronized 키워드가 걸린 객체에 접근할 경우 스레드 2는 해당 객체에 접근할 수 없고, 스레드 1이 작업을 끝날때까지 기다렸다가 작업을 이어갈 수 있다.

이렇게 할 경우 사용자는 프로그램을 실행했을 때 예상하는 결과를 얻을 수 있다.
여기서 멀티스레드 환경에서 결과가 보장되는 것을 Thread-safe라고 한다.

참고로 해당 키워드를 쓰면 결과를 보장받을 수 있다는 장점이 있지만, 해당 키워드가 있는 객체는 하나의 스레드가 작업이 끝나기 전까지 다른 스레드들이 접근을 할 수 없기 때문에 사용하지 않을때보다 속도가 느려질 수 있다는 단점이 있다.<br> 


## 5. 데드락

데드락은 교착상태라고도 불린다.<br>
스레드 1과 스레드 2에는 자원 1과 자원 2를 동시에 사용하여 수행해야 하는 작업이 있다.<br>
이때 스레드 1은 자원1을, 스레드 2는 자원 2를 가지고 있다면 둘 모두 자원이 하나씩 부족하기 때문에 실행을 더이상 할 수 없는 상황이 오게된다. 이런 상황을 데드락이라고한다.

데드락은 4가지 조건이 한번에 겹치는 경우 발생한다.
1. 상호배제 - 자원은 한번에 한 프로세스만 사용 가능하다
2. 점유와 대기 - 자원을 차지하고 다른 자원을 얻기까지 계속 대기한다.
3. 비선점 - 다른 스레드의 자원을 함부로 가져올 수 없다.
4. 환형대기 - 스레드가 서로 다음 스레드가 요구하는 자원을 가지고 있다.

위의 4가지 상황을 모두 성립하지 않는 이상 데드락은 발생하지 않으니, 코드를 작성할 때 적어도 한가지라도 성립하지 않도록 주의하자.

<br>

<hr>

- 관련 수업

[백기선님의 live-stydy](https://github.com/whiteship/live-study/issues) 10주차
