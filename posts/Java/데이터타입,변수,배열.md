|작성일|수정일|
|:----|:----|
|2020-11-17|2020-11-20|

--------

### 목표

자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.

### 학습할 것
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 및 2차 배열 선언하기
- 타입 추론, var

## 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

Primitive type. 기본형, 원시 타입이라고도 불리는 이 데이터 타입은 자바 언어에 기본으로 내장되어 있는 타입을 말한다.<br>
자바의 프리미티브 타입에는 총 8가지가 있는데, 크게 정수형, 실수형, 문자형, 논리형으로 나뉜다.<br>

### 정수형

||타입|메모리 크기|기본값|벙위|
|:---:|:---:|:---:|:---:|:---:|
|정수형|byte|1 byte|0|-2 <sup>7</sup> ~ 2 <sup>7</sup> -1|
|정수형|short|1 byte|0|-2 <sup>15</sup> ~ 2 <sup>15</sup> -1|
|정수형|int|4 byte|0|-2 <sup>31</sup> ~ 2 <sup>31</sup> -1|
|정수형|long|8 byte|0L|-2 <sup>63</sup> ~ 2 <sup>63</sup> -1|

정수형은 다시 4가지로 나뉜다. 그런데 숫자들의 범위를 보니 0을 기준으로 대칭되어 음수와 양수의 절댓값이 같지 않고, 양수의 절댓값은 항상 음수의 절댓값보다 1이 작은 것을 볼 수 있다.<br>
왜 이런 일이 일어난 것일까?<br>
정수형 중 가장 작은 byte 형을 기준으로 생각해보자.

컴퓨터는 0과 1, 2진수의 세계에 살고있는 기계이다. 그리고 컴퓨터에서 가장 작은 데이터 단위는 bit이고, 메모리 1칸 즉 1bit에는 숫자가 0 또는 1 한가지만 들어갈 수 있다.<br>
그런데 숫자를 쓰다보면 양수도 있고, 음수도 있기 때문에 이를 구분해 주고 싶은데, 컴퓨터는 '-' 문자를 알아들을 수 없으니, - 또한 0이나 1로 표현해야 했다.<br>
그래서 나온 방법이, 컴퓨터가 숫자를 읽을 때 제일 앞자리에 오는 숫자가 0으로 시작한다면 뒤에 오는 숫자는 양수를, 1로 시작한다면 음수로 구분짓는 것이다.<br>
byte 형은 크기가 1byte = 8bit 이므로 앞의 1칸은 양,음수를 표현하고, 뒤의 7칸이 나머지 숫자를 표현하게 된다.

![01](https://user-images.githubusercontent.com/53729311/99821285-34bf3600-2b95-11eb-9756-4a64f51c8985.jpg)

위의 그림처럼 제일 앞자리는 비우고 뒤의 7칸만으로 숫자를 표시하고 있는데 이렇게 쓰고보니 또 다른 문제가 생긴다.<br>
00000000은 0으로 시작하고, 뒤의 숫자가 0을 뜻하고 있으니 양수 0이다. 그리고 10000000은 1로 시작하고, 뒤의 숫자가 0을 뜻하니 음수 0이다.<br>
0이 두개나 생겨버렸고, -0이라는 처음보는 숫자가 생겨버린 것이다.<br>
이제 이 문제는 보수를 이용하여 해결할 수 있다.

#### 보수 - 어떤 수를 만들기 위해 보충해주어야 하는 수

보수에도 여러 종류가 있는데 그 중 *1의 보수*는 최댓값을 형성하는데 서로 보완관계에 있는 두 수를 말한다.<br>
> ex1. 10진수의 1의자리에서 가장 큰 수는 9이다. 이때 4의 1의 보수는 5가된다.<br>
> 3x2. 16진수에서 가장 큰 한자리 수는 9f이다. 이때 9의 1의 보수는 6이된다.

*2의 보수*는 다음 자릿수로 넘어가기 위해 서로 보완관계에 있는 두 수를 말한다.<br>
> ex1. 10진수의 1의자리 수에서 2의자리를 넘어가면 만날 수 있는 첫번째 수는 10이다. 이때 4의 2의 보수는 6이된다.
> ex2. 2진수의 1의자리 수에서 2의자리를 넘어가면 만날 수 있는 첫번째 수는 10이다. 이때 1의 2의 보수는 1이 된다.

보수에 대해 알아보았으니 이것과, 컴퓨터는 저장하려는 값이 지정된 메모리를 넘어가면 넘어가는 부분은 무시한다는 사실을 이용하여 양, 음수, 0을 표현해 보자.<br>
부호만 다르고 절댓값이 같은 두 수는 더하면 0이 되는데, 2의 보수관계에 있는 두 수를 더하면 새로운 자릿수가 생기고, 원래 있던 자리의 수들은 전부 0이 된다.
예를들어 양수 1과 음수 1을 더하면 0000 0000이 되어야 한다. 양수 1은 0000 0001이니, 음수 1은 1111 1111이 될것이다.<br>
> 0000 00001과 1111 1111을 더하면 1 0000 0000이지만 byte 타입에서는 범위를 벗어난 부분은 무시하고 뒤의 0000 0000만 남는다.<br>
양수 2와 음수 2도 0000 0010과 1111 1110으로 두 수를 더하면 결과가 0000 0000이 나온다.<br>
양의 숫자의 2의 보수를 이용하여 절댓값이 같은 음수를 표현해주면, 첫번째 자리는 무조건 1이 나오니 음수라는 것을 알 수 있고, 0의 2의 보수 또한 0이기 때문에 앞에서 발생한 -0문제도 해결할 수 있다.

그래서 정수형의 범위를 봤을 때 음수와 양수의 절댓값을 비교했을 때 양수는 0을 포함하고 있기 때문에 음수보다 항상 1씩 작다.<br>
또, byte형의 범위가 $$2^8$$이 아닌 2 <sup>7</sup> 내외이고, int형의 범위가 2 <sup>15</sup>내외인 것도 제일 앞자리를 부호를 설명하는데 쓰고있어서 그렇다는 것도 알 수 있다.

> 쓰다보니 설명이 이상해져서 헷갈리는데 [컴퓨터로 숫자표현하기](https://yo0on.github.io/posts/CS01.%EC%88%AB%EC%9E%90%ED%91%9C%ED%98%84/) 참고<br>

### 실수형

||타입|메모리 크기|기본값|범위|
|:---:|:---:|:---:|:---:|:---:|
|실수형|float|4 byte|0.0F|-3.4 * 10 <sup>-38</sup> ~ 3.4 * 10 <sup>38</sup>의 근사값|
|실수형|double|8 byte|0.0|1.7 * 10 <sup>-308</sup> ~ 1.7 * 10 <sup>308</sup>의 근사값|

여기서 잠깐, 컴퓨터가 숫자를 어떻게 표현하는지 알아보자.<br>
컴퓨터가 실수를 나타낼 때는 고정 소수점과 부동 소수점 방식이 있다.<br>

![고정소수점](https://user-images.githubusercontent.com/53729311/99824592-41458d80-2b99-11eb-8bae-e954d01ce9ca.jpg)

고정 소수점은 이름 그대로 소수점을 고정시켜 두는 것이다. 첫번째는 부호를 위한 자리, 뒤의 지정된 몇칸은 정수부, 나머지는 실수부를 뜻한다.

![부동소수점](https://user-images.githubusercontent.com/53729311/99824614-486c9b80-2b99-11eb-8fd6-4b26c76f711d.jpg)

부동 소수점은 첫번째는 부호, 중간에는 지수부, 마지막에는 가수부가 온다. 가수부에서는 소수점을 제외한 숫자만 저장하고, 지수부에서는 가수부의 어디쯤에 소수점이 있는지를 나타낸다.<br>
소수점을 움직여서 표현하기 때문에 고정 소수점을 이용했을 때보다 표현 범위가 넓다는 장점이 있지만, 고정 소수점에 비해 오차가 크다는 단점이 있다.

그리고 Java의 float와 double은 부동 소수점을 이용하여 실수를 표현하고 있기 때문에 연산시 값이 정확하지 않을 수 있으니 변수 선언시 주의해야한다.
> 이에 대한 문제와 해결법에 대해 알아보고 싶다면 구글에 java Floating point를 검색하거나 [Java8 Documentation](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2.3)을 읽어보자.<br>

### 논리형 & 문자형

||타입|메모리 크기|기본값|범위|
|:---:|:---:|:---:|:---:|:---:|
|논리형|boolean|1 byte|false|true, false|
|문자형|char|2 byte|'\u0000'|0 ~ 65,535|

논리형의 경우 참, 거짓만을 판단하고, true는 1, false는 0의 값을 가진다.<br>
문자형의 경우 유니코드를 사용하기때문에 2byte를 이용하여 표현한다.<br>

<br>

## 2. 프리미티브 타입과 레퍼런스 타입

레퍼런스 타입은 *참조형*이라고 부르는 타입이다. 대표적인 레퍼런스 타입에는 String, 배열, enum 등이 있다.<br>
프리미티브 타입과 차이가 무엇인가 하면, 저장하는 방식이 다르다.

첫번째 시간에 JVM의 구조를 설명할 때 JVM의 메모리 구조에는 메소드, Stack, Heap 영역이 있다고 설명했다.<br>
그리고 그 중 Heap영역에는 객체, 배열, 참조변수의 값, 인스턴스의 멤버 변수가 저장된다고 했는데, 이 내용이 여기와 연결된다.

프리미티브 타입은 변수를 선언 할 때 메모리에 각 타입에 맞게 크기가 고정되어 있고 저장하려는 위치에 데이터가 들어가게 된다.<br>
하지만 레퍼런스 타입은 변수 선언시 크기가 정해져 있지 않고, 저장 위치에 데이터가 아닌 참조 주소값이 들어가게 된다.

예를들어 `A a = new A()`를 실행해보자.<br>
가장 처음 A()에서 객체가 생성되고, new 키워드에서 JVM은 Heap에 공간을 마련해 생성된 객체를 넣는다.
 이제 선언된 A타입의 변수 a는 Stack 영역에 저장되는데, Stack에 있는 a가 저장된 메모리에는 Heap에 위치한 객체의 주소가 저장된다.<br>

<br>

 ## 3. 리터럴
 
 리터럴은 데이터, 값 자체를 뜻한다.<br>
 `String a = "hello"` 라고 한다면 hello가 리터럴이다.<br>
 
 <br>
 
 ## 4. 변수 선언 및 초기화 하는 방법
 
 변수를 선언할 때는 아래처럼 데이터타입과 변수이름을 이용하여 선언한다. 선언을 하게되면 메모리에 변수를 위해 데이터를 저장할 공간을 지정해준다.
 ```java
 int a;
```

초기화는 처음 값을 지정해 주는 것을 말한다.
```java
int a = 1;
B b = new B();
```
이 외에도 초기화 블럭을 이용할 수도 있다.
```java
class Test{
  static {
    // 클래스 초기화 블럭
  }
  {
    // 인스턴스 초기화 블럭
  }
}
```

<br>

## 5. 변수의 스코프와 라이프 타임

변수의 Scope라고 하면 변수를 사용할 수 있는 범위를 뜻한다. 여기서 범위는 어느 영역에서 사용하는가에 대한 범위이다.<br>
변수가 어디서 선언되었는가에 따라서 변수의 scope는 아래의 표처럼 바뀐다.

|변수의 종류|선언 위치|변수의 Scope|
|:----:|:-----:|:--------:|:------:|
|클래스 변수|클래스 영역|클래스 전역|
|인스턴스 변수|클래스 영역|각 인스턴스|
|지역 변수|메소드 영역|메소드 내부|

라이프 타임은 어떤 변수가 메모리에서 사라질 때까지 살아있는 시기를 뜻한다.<br>
변수가 사라지는 시기는 1주차에 JVM에서 한번 봤었는데, 클래스 변수의 경우 프로그램이 종료될 때, 인스턴스 변수의 경우 해당 변수의 사용이 끝나게 되어 GC의 대상이 되었을 때, 지역변수의 경우 메소드가 끝났을 때이다.<br>

<br>


## 6. 타입 변환, 캐스팅, 그리고  타입 프로모션

타입 변환은 데이터의 타입을 바꿔주는 것을 말한다.<br>
Java는 연산을 할 때 같은 데이터 타입끼리만 가능한데, 타입 변환을 이용하면 서로 다른 데이터 타입이더라도, 같은 데이터 타입으로 맞춰줄 수 있다.

이제 여기서 캐스팅은 강제로 데이터 타입을 바꾸는 것이고, 타입 프로모션은 자동으로 형변환 되는 것을 말한다.<br>
강제로 데이터 타입을 바꾼다는 것은 크기가 큰 자료형을 본인보다 작은 자료형에 대입하는 것을 뜻한다..
반대로 타입 프로모션은 작은 자료형을 큰 자료형에 대입하는 것을 뜻한다.<br>

<br>


## 7. 1차, 2차 배열 선언하기

Java에서 배열을 뜻할 때는 [ ]를 이용하여 표현한다.

```java
String[] stringArray = new String[배열의 크기];
```
위와 같이 작성하는데 Java에서 배열은 처음 생성할 때 크기를 지정해 주어야 한다는 것을 조심하자.<br>
참고로 main 메서드를 보면 매개변수로 `String[] args`를 받는 것을 볼 수 있는데, 이 또한 배열이다.

2차 배열은 배열 안에 배열이 하나 더 들어있는 형태를 말한다.

```java
int[][] intArray = new int[겉 배열 크기][속 배열 크기]
```
위츼 코드처럼 작성하면 2차원 배열이 만들어 지는데, 만약 ```int[][] intArray = new int[2][5];```라고 작성했다면 [[1,2,3,4,5], [5,6,7,8,9]] 처럼 작성될 것이다.<br>
속에 들어갈 배열의 크기는 필수로 적을 필요는 없다.<br>

<br>

## 8. 타입 추론, var

타입 추론은 코드를 작성할 때는 데이터 타입이 정해지지 않았지만, 컴파일 시 컴파일러가 타입을 추론하는 것을 뜻한다.<br>
이전에는 제네릭이나 람다에서만 사용했으나 Java10부터 *var*를 이용하여 데이터 타입을 선언하여 이용할 수 있도록 변경되었다.

<br>

<hr>

- 관련 수업

[백기선님의 live-stydy](https://github.com/whiteship/live-study/issues) 2주차

<br>

- 참고

[Java Documentation](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2.3)
